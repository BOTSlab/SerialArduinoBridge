#ifdef USE_MSM

/** 
 * Code to interact with a MinSegMega connected to two Lego NXT motors.
 */

// Universal constants
double DEGREES_TO_RADIANS = M_PI / 180.0;
double RADIANS_TO_DEGREES = 180.0 / M_PI;

// Parameters used to convert from encoder values to movements of the wheels
// along the floor.
double WHEEL_RADIUS_MM = 28.0;
double RADIANS_PER_STEP = 0.5 * DEGREES_TO_RADIANS; // Each encoder pulse is 0.5 deg of a turn
double DISTANCE_PER_STEP = WHEEL_RADIUS_MM * RADIANS_PER_STEP;

// Baseline distance between the wheels in mm
double BASELINE_MM = 103.0;
double HALF_BASELINE_MM = BASELINE_MM / 2.0;

// Pin ID's for setting motors
int MOTOR_RIGHT_FORWARD = 44;  // Right motor Forward (M1)
int MOTOR_RIGHT_BACKWARD = 45; // Right motor Reverse (M2)
int MOTOR_LEFT_FORWARD = 2;    // Left motor Forward  (M3)
int MOTOR_LEFT_BACKWARD = 46;  // Left motor Reverse  (M4)

// Current pose represented in metres and radians.
double x = 0, y = 0, theta = 0;

/*******************  Encoder Variables ********************/
// Right encoder pins
int encoderPin_RA = 19;
int encoderPin_RB = 18;

// Position tracking variables for left/right encoders
volatile int encoder_pos_right = 0;
volatile int encoder_pos_left = 0;
int last_encoder_pos_right = 0;
int last_encoder_pos_left = 0;

// Quadrature encoder state variables set during interrupts
volatile bool LA_state = false; // Left encoder A
volatile bool LB_state = false; // Left encoder B
volatile bool RA_state = false; // Right encoder A
volatile bool RB_state = false; // Right encoder B
/*************************************************************/

// Directly from pages 186-7 of "Introduction to Mobile Robots" by Siegwart 
// and Nourbakhsh, First edition.

void updatePose() {
    // Distance travelled by left and right wheels
    double delta_s_l = DISTANCE_PER_STEP * 
                        (encoder_pos_left - last_encoder_pos_left);
    double delta_s_r = DISTANCE_PER_STEP *
                        (encoder_pos_right - last_encoder_pos_right);

    double delta_s = (delta_s_l + delta_s_r) / 2.0;
    double delta_theta = (delta_s_r - delta_s_l) / BASELINE_MM;

    x += delta_s * cos(theta + delta_theta / 2.0);
    y += delta_s * sin(theta + delta_theta / 2.0);
    theta += delta_theta;
}


long msmGetX() {
    return (long)(x * 1000);
}

long msmGetY() {
    return (long)(y * 1000);
}

long msmGetTheta() {
    return (long)(theta * 1000);
}

void msmSetMotors(int dir) {
  switch(dir){
    case 0: // Stop
      digitalWrite(MOTOR_RIGHT_FORWARD, LOW);
      digitalWrite(MOTOR_RIGHT_BACKWARD, LOW);
      digitalWrite(MOTOR_LEFT_FORWARD, LOW);
      digitalWrite(MOTOR_LEFT_BACKWARD, LOW);
      break;
    case 1: // Forward
      digitalWrite(MOTOR_RIGHT_FORWARD, HIGH);
      digitalWrite(MOTOR_RIGHT_BACKWARD, LOW);
      digitalWrite(MOTOR_LEFT_FORWARD, HIGH);
      digitalWrite(MOTOR_LEFT_BACKWARD, LOW);
      break;
    case 2: // Reverse
      digitalWrite(MOTOR_RIGHT_FORWARD, LOW);
      digitalWrite(MOTOR_RIGHT_BACKWARD, HIGH);
      digitalWrite(MOTOR_LEFT_FORWARD, LOW);
      digitalWrite(MOTOR_LEFT_BACKWARD, HIGH);
      break;
    case 3: // Turn Left
      digitalWrite(MOTOR_RIGHT_FORWARD, HIGH);
      digitalWrite(MOTOR_RIGHT_BACKWARD, LOW);
      digitalWrite(MOTOR_LEFT_FORWARD, LOW);
      digitalWrite(MOTOR_LEFT_BACKWARD, HIGH);
      break;
    case 4: // Turn Right
      digitalWrite(MOTOR_RIGHT_FORWARD, LOW);
      digitalWrite(MOTOR_RIGHT_BACKWARD, HIGH);
      digitalWrite(MOTOR_LEFT_FORWARD, HIGH);
      digitalWrite(MOTOR_LEFT_BACKWARD, LOW);
      break;
  }
}

/******************************************************************************

  Interrupt functions to determine the direction and amount of rotation for each
  motor. The encoder on each motor takes two readings (A and B). The graphs below
  illustrate the pulse patterns generated by rotation in each direction.

                A leads B                             B leads A
      __________________________             __________________________
      |                                      |
      |__      ____      ____                |____      ____      ____ 
Pin A |  |____|    |____|    |__      Pin A  |    |____|    |____|    |
      |                                      |
      |____      ____      ____              |__      ____      ____   
Pin B |    |____|    |____|    |      Pin B  |  |____|    |____|    |__
      |                                      |
      |__________________________            |__________________________
      
            Moving Forward                         Moving Backward  
      
*******************************************************************************/

// Interrupt triggered on RA changing state
void doEncoderRA(){
  RA_state = !RA_state;
  if (RA_state != RB_state){
    encoder_pos_right++;
  }
  else{
    encoder_pos_right--;
  }
}

// Interrupt triggered on RB changing state
void doEncoderRB(){
  RB_state = !RB_state;
  if (RA_state == RB_state){
    encoder_pos_right++;
  }
  else{
    encoder_pos_right--;
  }
}

// Interrupt triggered on LA changing state
void doEncoderLA(){
  LA_state = !LA_state;
  if (LA_state != LB_state){
    encoder_pos_left++;
  }
  else{
    encoder_pos_left--;
  }
}

// Interrupt triggered on LB changing state
void doEncoderLB(){
  LB_state = !LB_state;
  if (LA_state == LB_state){
    encoder_pos_left++;
  }
  else{
    encoder_pos_left--;
  }
}

void msmSetup(){
  // Set initial state for right encoder
  pinMode(encoderPin_RA, INPUT);
  pinMode(encoderPin_RB, INPUT);
  RA_state = digitalRead(encoderPin_RA);
  RB_state = digitalRead(encoderPin_RB);
  
  // Set initial state for left encoder
  // Encoder is attached to unmapped pins E6/E7, hence the low level port manipulation
  DDRE &= 0x3f;
  PORTE |= 0xC0;
  LA_state = ((PINE & 0x40) == 0x40);
  LB_state = ((PINE & 0x80) == 0x80);
  
  // Attach interrupt functions for each encoder pin
  // to their corresponding interrupt pin. Each time
  // the value of an encoder pin changes, the program
  // pauses its routine to evaluate the triggered function.
  attachInterrupt(5, doEncoderRB, CHANGE);
  attachInterrupt(4, doEncoderRA, CHANGE);
  attachInterrupt(6, doEncoderLA, CHANGE);
  attachInterrupt(7, doEncoderLB, CHANGE);
  
  // Set motor control pins to be outputs
  pinMode(MOTOR_RIGHT_FORWARD, OUTPUT);
  pinMode(MOTOR_RIGHT_BACKWARD, OUTPUT);
  pinMode(MOTOR_LEFT_FORWARD, OUTPUT);
  pinMode(MOTOR_LEFT_BACKWARD, OUTPUT);
}

void msmLoop(){
    updatePose();

    last_encoder_pos_left = encoder_pos_left;
    last_encoder_pos_right = encoder_pos_right;
}

#endif
